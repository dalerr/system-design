# Масштабирование систем

## Определение

**Масштабирование (Scaling)** — это способность системы обрабатывать увеличение нагрузки путем добавления или изменения ресурсов.

При росте нагрузки система должна либо увеличить мощность существующих ресурсов, либо добавить новые ресурсы.

---

## Типы масштабирования

### 1. Вертикальное масштабирование (Scale Up)

**Определение:**
Увеличение ресурсов **одного сервера** — добавление CPU, RAM, дискового пространства или улучшение производительности существующих компонентов.

**Также называется:**
- Scale Up
- Vertical Scaling
- Увеличение мощности сервера

**Что увеличивается:**
- CPU (процессор) — больше ядер, выше частота
- RAM (память) — больше оперативной памяти
- Диск — больше места, быстрее скорость (SSD вместо HDD)
- Сетевая карта — выше пропускная способность

**Примеры:**
```
Было: 4 CPU cores, 16GB RAM, 500GB HDD
Стало: 16 CPU cores, 64GB RAM, 2TB SSD
```

**Преимущества:**
- ✅ Простота реализации — не нужно менять архитектуру
- ✅ Нет проблем с распределением данных
- ✅ Нет network latency между компонентами
- ✅ Проще управление — один сервер вместо многих
- ✅ Подходит для монолитных приложений
- ✅ Нет проблем с консистентностью данных

**Недостатки:**
- ❌ Физические ограничения — нельзя бесконечно увеличивать сервер
- ❌ Дорого — мощные серверы стоят дорого
- ❌ Single point of failure — если сервер упадет, система недоступна
- ❌ Ограниченная масштабируемость — рано или поздно достигнете предела
- ❌ Простой на время обновления — нужно останавливать систему для апгрейда

**Когда использовать:**
- Малые и средние нагрузки
- Монолитные приложения
- Системы с низкой нагрузкой
- Быстрый старт проекта
- Когда горизонтальное масштабирование сложно реализовать
- Базы данных, которые сложно шардить

**Примеры систем:**
- Небольшие веб-приложения
- Внутренние инструменты компании
- Прототипы и MVP
- Системы с предсказуемой нагрузкой

**Технологии:**
- Облачные провайдеры: AWS (увеличение instance типа), Google Cloud, Azure
- Физические серверы: апгрейд железа

---

### 2. Горизонтальное масштабирование (Scale Out)

**Определение:**
Добавление **новых серверов** для распределения нагрузки между ними.

**Также называется:**
- Scale Out
- Horizontal Scaling
- Добавление серверов

**Как работает:**
```
Было: 1 сервер обрабатывает все запросы
Стало: 5 серверов, каждый обрабатывает часть запросов
```

**Что требуется:**
- **Load Balancer** — распределяет запросы между серверами
- **Stateless сервисы** — серверы не хранят состояние между запросами
- **Распределенные БД** — данные распределены между серверами (шардинг, репликация)
- **Сервис обнаружения** — сервисы знают о существовании друг друга

**Преимущества:**
- ✅ Практически неограниченное масштабирование — можно добавлять серверы бесконечно
- ✅ Высокая доступность — если один сервер упадет, другие продолжают работать
- ✅ Гибкость — можно добавлять/удалять серверы по требованию
- ✅ Экономичность — можно использовать более дешевые серверы
- ✅ Отказоустойчивость — нет single point of failure
- ✅ Подходит для облачных систем

**Недостатки:**
- ❌ Сложность реализации — нужно менять архитектуру
- ❌ Network latency — задержки между серверами
- ❌ Сложность управления — нужно оркестрировать множество серверов
- ❌ Проблемы с консистентностью — данные распределены между серверами
- ❌ Сложность дебага — проблемы могут быть в любом сервере
- ❌ Требует stateless архитектуру

**Когда использовать:**
- Высоконагруженные системы
- Микросервисная архитектура
- Облачные системы
- Системы с непредсказуемой нагрузкой
- Системы, требующие высокой доступности
- Системы с пиковыми нагрузками

**Примеры систем:**
- Google, Facebook, Amazon — миллионы пользователей
- Высоконагруженные API
- Системы с сезонными пиками (Black Friday)
- Облачные SaaS приложения

**Технологии:**
- Load Balancers: AWS ELB, NGINX, HAProxy
- Container Orchestration: Kubernetes, Docker Swarm
- Auto-scaling: AWS Auto Scaling, Google Cloud Autoscaler
- Service Discovery: Consul, Eureka, etcd

---

## Сравнительная таблица

| Характеристика | Вертикальное (Scale Up) | Горизонтальное (Scale Out) |
|----------------|-------------------------|----------------------------|
| **Сложность** | Низкая | Высокая |
| **Стоимость** | Высокая (мощные серверы) | Средняя (много простых серверов) |
| **Масштабируемость** | Ограничена | Практически неограничена |
| **Отказоустойчивость** | Низкая (single point of failure) | Высокая |
| **Latency** | Низкая (все в одном месте) | Выше (network latency) |
| **Управление** | Простое | Сложное |
| **Подходит для** | Монолиты, малые системы | Микросервисы, большие системы |
| **Время на масштабирование** | Долго (апгрейд железа) | Быстро (добавление серверов) |

---

## Гибридный подход

**Определение:**
Комбинация вертикального и горизонтального масштабирования.

**Пример:**
```
1. Начинаем с вертикального масштабирования (проще)
2. При достижении предела переходим на горизонтальное
3. Используем мощные серверы + много серверов
```

**Стратегия:**
- Вертикальное масштабирование для критичных компонентов (БД)
- Горизонтальное масштабирование для прикладного слоя (API, веб-серверы)

---

## Масштабирование по компонентам

### 1. Масштабирование веб-серверов

**Вертикальное:**
- Увеличение CPU и RAM для обработки большего количества запросов

**Горизонтальное:**
- Добавление веб-серверов за Load Balancer
- Stateless архитектура (сессии в Redis, не на сервере)

**Пример:**
```
Load Balancer
    ├── Web Server 1
    ├── Web Server 2
    ├── Web Server 3
    └── Web Server 4
```

---

### 2. Масштабирование баз данных

**Вертикальное:**
- Увеличение ресурсов сервера БД
- Оптимизация запросов и индексов

**Горизонтальное:**
- **Read Replicas** — реплики для чтения
- **Шардинг (Partitioning)** — разделение данных по серверам
- **Master-Slave** — один master для записи, несколько slaves для чтения

**Пример шардинга:**
```
User ID 1-1000    → Database Shard 1
User ID 1001-2000 → Database Shard 2
User ID 2001-3000 → Database Shard 3
```

**Пример read replicas:**
```
Master DB (запись)
    ├── Read Replica 1 (чтение)
    ├── Read Replica 2 (чтение)
    └── Read Replica 3 (чтение)
```

---

### 3. Масштабирование кешей

**Вертикальное:**
- Увеличение памяти для Redis/Memcached

**Горизонтальное:**
- **Redis Cluster** — распределенный кеш
- **Consistent Hashing** — распределение ключей по серверам

**Пример:**
```
Cache Cluster
    ├── Redis Node 1
    ├── Redis Node 2
    └── Redis Node 3
```

---

### 4. Масштабирование очередей

**Вертикальное:**
- Увеличение ресурсов для обработки большего количества сообщений

**Горизонтальное:**
- **Kafka Cluster** — несколько брокеров
- **RabbitMQ Cluster** — несколько узлов
- Партиционирование топиков

**Пример:**
```
Kafka Cluster
    ├── Broker 1 (Topic partitions 0, 3, 6)
    ├── Broker 2 (Topic partitions 1, 4, 7)
    └── Broker 3 (Topic partitions 2, 5, 8)
```

---

## Auto-scaling (автомасштабирование)

**Определение:**
Автоматическое добавление/удаление ресурсов на основе текущей нагрузки.

**Метрики для auto-scaling:**
- CPU utilization (загрузка процессора)
- Memory utilization (использование памяти)
- Request rate (количество запросов)
- Queue depth (глубина очереди)
- Response time (время ответа)

**Примеры:**

**AWS Auto Scaling:**
```yaml
Min instances: 2
Max instances: 10
Target CPU: 70%
Scale up: при CPU > 70%
Scale down: при CPU < 30%
```

**Kubernetes HPA (Horizontal Pod Autoscaler):**
```yaml
Min replicas: 3
Max replicas: 20
Target CPU: 80%
```

**Преимущества:**
- ✅ Автоматическая реакция на нагрузку
- ✅ Экономия ресурсов (удаление при низкой нагрузке)
- ✅ Высокая доступность (добавление при высокой нагрузке)

**Недостатки:**
- ❌ Нужна правильная настройка метрик
- ❌ Возможны колебания (thrashing) при неправильной настройке
- ❌ Задержка на масштабирование (cold start)

---

## Стратегии масштабирования

### 1. Predictive Scaling (прогнозирующее)

**Определение:**
Масштабирование на основе прогноза нагрузки.

**Примеры:**
- Увеличение серверов перед Black Friday
- Увеличение перед запуском рекламной кампании
- Уменьшение в ночное время

**Преимущества:**
- ✅ Готовность к пиковой нагрузке
- ✅ Плавное масштабирование

**Недостатки:**
- ❌ Нужны точные прогнозы
- ❌ Возможны лишние расходы при неточном прогнозе

---

### 2. Reactive Scaling (реактивное)

**Определение:**
Масштабирование на основе текущей нагрузки.

**Примеры:**
- Auto-scaling на основе CPU
- Auto-scaling на основе количества запросов

**Преимущества:**
- ✅ Реакция на реальную нагрузку
- ✅ Экономия ресурсов

**Недостатки:**
- ❌ Задержка на масштабирование
- ❌ Возможны проблемы при резком росте нагрузки

---

### 3. Hybrid Scaling (гибридное)

**Определение:**
Комбинация predictive и reactive scaling.

**Пример:**
- Predictive scaling для известных событий (Black Friday)
- Reactive scaling для неожиданных пиков

---

## Примеры из реальных систем

### Netflix

**Архитектура:**
- Горизонтальное масштабирование
- Микросервисы
- Auto-scaling на основе нагрузки
- Multi-region deployment

**Масштаб:**
- Миллионы одновременных пользователей
- Тысячи сервисов
- Автоматическое масштабирование

---

### Amazon

**Архитектура:**
- Горизонтальное масштабирование
- Шардинг БД
- Read replicas
- Кеширование на всех уровнях

**Масштаб:**
- Миллионы товаров
- Миллионы заказов в день
- Тысячи серверов

---

### Google Search

**Архитектура:**
- Горизонтальное масштабирование
- Распределенные индексы
- Географическое распределение

**Масштаб:**
- Миллиарды запросов в день
- Тысячи серверов
- Низкая latency (p95 < 100ms)

---

## Резюме

**Ключевые принципы:**

1. ✅ **Начинайте с вертикального** — проще для малых систем
2. ✅ **Планируйте горизонтальное** — для роста и высокой доступности
3. ✅ **Используйте auto-scaling** — автоматическая реакция на нагрузку
4. ✅ **Масштабируйте по компонентам** — разные стратегии для разных частей системы
5. ✅ **Мониторьте метрики** — понимайте когда нужно масштабировать

**Правило выбора:**

- **Вертикальное масштабирование:**
  - Малые и средние системы
  - Монолитные приложения
  - Быстрый старт
  - Предсказуемая нагрузка

- **Горизонтальное масштабирование:**
  - Высоконагруженные системы
  - Микросервисы
  - Непредсказуемая нагрузка
  - Требования высокой доступности

**Помните:** Правильный выбор стратегии масштабирования критичен для успеха системы. Неправильный выбор приводит к проблемам с производительностью, доступностью и стоимостью.

