# Event-driven архитектуры

## Определение

**Event-driven архитектура (EDA)** — это архитектурный паттерн, где компоненты системы взаимодействуют через **события (events)** вместо прямых вызовов.

В event-driven системе компоненты **публикуют события** при изменении состояния, а другие компоненты **подписываются** на эти события и реагируют на них асинхронно.

---

## Основные концепции

### Event (Событие)

**Определение:**
Факт, который произошел в системе и представляет изменение состояния.

**Характеристики:**
- **Immutable** (неизменяемое) — события не изменяются после создания
- **Timestamped** (с временной меткой) — когда произошло событие
- **Self-contained** (самодостаточное) — содержит всю необходимую информацию

**Примеры событий:**
```json
{
  "event_type": "OrderCreated",
  "event_id": "evt_123",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "order_id": "ord_456",
    "user_id": "usr_789",
    "amount": 99.99,
    "items": [...]
  }
}
```

**Типы событий:**
- **Domain events** — бизнес-события (OrderCreated, PaymentProcessed)
- **Integration events** — события для интеграции между сервисами
- **System events** — системные события (ServiceStarted, HealthCheck)

---

### Event Producer (Производитель событий)

**Определение:**
Компонент, который создает и публикует события.

**Примеры:**
- Order Service публикует событие `OrderCreated`
- Payment Service публикует событие `PaymentProcessed`
- User Service публикует событие `UserRegistered`

**Реализация:**
```python
class OrderService:
    def create_order(self, order_data):
        order = self.save_order(order_data)
        
        # Публикуем событие
        event = {
            "event_type": "OrderCreated",
            "order_id": order.id,
            "user_id": order.user_id,
            "amount": order.amount
        }
        event_bus.publish("orders", event)
        
        return order
```

---

### Event Consumer (Потребитель событий)

**Определение:**
Компонент, который подписывается на события и обрабатывает их.

**Примеры:**
- Notification Service подписывается на `OrderCreated` и отправляет email
- Inventory Service подписывается на `OrderCreated` и резервирует товары
- Analytics Service подписывается на все события для аналитики

**Реализация:**
```python
class NotificationService:
    def __init__(self):
        event_bus.subscribe("orders", self.handle_order_created)
    
    def handle_order_created(self, event):
        if event["event_type"] == "OrderCreated":
            self.send_order_confirmation_email(
                user_id=event["user_id"],
                order_id=event["order_id"]
            )
```

---

### Event Bus (Шина событий)

**Определение:**
Инфраструктурный компонент, который обеспечивает доставку событий от producers к consumers.

**Функции:**
- Прием событий от producers
- Хранение событий (опционально)
- Маршрутизация событий к подписчикам
- Гарантия доставки (at-least-once, exactly-once)

**Технологии:**
- **Apache Kafka** — распределенная платформа для потоковой обработки
- **RabbitMQ** — message broker с поддержкой различных паттернов
- **AWS Kinesis** — управляемый сервис для потоковой обработки
- **Google Pub/Sub** — управляемый message broker от Google
- **Redis Streams** — потоковая обработка на основе Redis
- **Azure Event Hubs** — управляемый event streaming от Microsoft

---

## Преимущества Event-driven архитектуры

### 1. Decoupling (Развязка)

**Определение:**
Компоненты не знают друг о друге напрямую.

**Преимущества:**
- ✅ Независимая разработка сервисов
- ✅ Независимое развертывание
- ✅ Легче добавлять новые подписчики
- ✅ Меньше зависимостей между сервисами

**Пример:**
```
Без event-driven:
  Order Service → Notification Service (прямой вызов)
  Order Service → Inventory Service (прямой вызов)
  Order Service → Analytics Service (прямой вызов)
  
  Проблема: Order Service зависит от всех сервисов

С event-driven:
  Order Service → Event Bus → Notification Service
                  Event Bus → Inventory Service
                  Event Bus → Analytics Service
  
  Преимущество: Order Service не знает о подписчиках
```

---

### 2. Асинхронность

**Определение:**
Обработка событий происходит асинхронно, не блокируя основной поток.

**Преимущества:**
- ✅ Высокая производительность
- ✅ Лучшая масштабируемость
- ✅ Нет блокировок
- ✅ Система продолжает работать даже при медленных подписчиках

**Пример:**
```
Синхронно:
  Order Service создает заказ
  → Ждет отправки email (2 секунды)
  → Ждет обновления инвентаря (1 секунда)
  → Ждет записи в аналитику (1 секунда)
  Итого: 4 секунды

Асинхронно:
  Order Service создает заказ
  → Публикует событие (10ms)
  → Возвращает ответ (10ms)
  Итого: 20ms
  
  Подписчики обрабатывают события параллельно
```

---

### 3. Масштабируемость

**Определение:**
Независимые компоненты можно масштабировать отдельно.

**Преимущества:**
- ✅ Масштабирование только нужных компонентов
- ✅ Разные компоненты могут иметь разную нагрузку
- ✅ Горизонтальное масштабирование consumers

**Пример:**
```
Notification Service получает 1000 событий/сек
→ Масштабируем только Notification Service
→ Другие сервисы не затрагиваются
```

---

### 4. Гибкость

**Определение:**
Легко добавлять новые подписчики без изменения существующих компонентов.

**Преимущества:**
- ✅ Добавление новой функциональности без изменения кода
- ✅ Легкая интеграция новых сервисов
- ✅ Гибкость в развитии системы

**Пример:**
```
Изначально:
  OrderCreated → Notification Service
  OrderCreated → Inventory Service

Добавляем новый сервис:
  OrderCreated → Notification Service
  OrderCreated → Inventory Service
  OrderCreated → Recommendation Service (новый, без изменения существующих)
```

---

### 5. Аудит и Replay

**Определение:**
События можно хранить и воспроизводить для аудита и отладки.

**Преимущества:**
- ✅ История всех изменений
- ✅ Возможность воспроизвести события
- ✅ Отладка проблем
- ✅ Восстановление состояния

**Пример:**
```
Проблема: База данных повреждена
Решение: Воспроизводим все события с начала
→ Восстанавливаем состояние системы
```

---

## Недостатки Event-driven архитектуры

### 1. Сложность

**Проблемы:**
- ❌ Сложнее понять flow системы
- ❌ Сложнее отлаживать (асинхронность)
- ❌ Нужна инфраструктура (event bus)
- ❌ Сложнее тестировать

---

### 2. Eventual Consistency

**Проблемы:**
- ❌ Данные могут быть неконсистентны временно
- ❌ Нужна обработка дубликатов событий
- ❌ Сложнее гарантировать порядок событий

---

### 3. Сложность мониторинга

**Проблемы:**
- ❌ Сложнее отслеживать flow событий
- ❌ Нужен мониторинг event bus
- ❌ Сложнее понимать зависимости

---

## Паттерны Event-driven архитектуры

### 1. Event Sourcing

**Определение:**
Хранение всех изменений состояния как последовательности событий.

**Принцип:**
Вместо хранения текущего состояния, храним все события, которые привели к этому состоянию.

**Пример:**
```
Традиционный подход:
  Order: { id: 1, status: "shipped", amount: 100 }

Event Sourcing:
  OrderCreated: { order_id: 1, amount: 100 }
  OrderPaid: { order_id: 1, payment_id: "pay_123" }
  OrderShipped: { order_id: 1, tracking: "TRACK123" }
  
  Текущее состояние вычисляется из событий
```

**Преимущества:**
- ✅ Полная история изменений
- ✅ Аудит всех операций
- ✅ Возможность воспроизвести состояние
- ✅ Time travel (вернуться к любому моменту)

**Недостатки:**
- ❌ Сложность реализации
- ❌ Нужно пересчитывать состояние
- ❌ Большой объем данных

**Когда использовать:**
- Системы, требующие полного аудита
- Финансовые системы
- Системы с требованием к истории изменений

---

### 2. CQRS (Command Query Responsibility Segregation)

**Определение:**
Разделение операций записи (Commands) и чтения (Queries) на отдельные модели.

**Принцип:**
- **Command** — изменяет состояние (создание, обновление, удаление)
- **Query** — читает состояние (без изменений)

**Пример:**
```
Традиционный подход:
  Order Service: читает и пишет в одну БД

CQRS:
  Command Side: Order Service пишет в БД записи
  Query Side: Order Read Service читает из оптимизированной БД чтения
  
  События синхронизируют данные между сторонами
```

**Преимущества:**
- ✅ Оптимизация для чтения и записи отдельно
- ✅ Масштабирование чтения независимо
- ✅ Разные модели данных для чтения и записи

**Недостатки:**
- ❌ Сложность синхронизации
- ❌ Eventual consistency между сторонами
- ❌ Больше инфраструктуры

**Когда использовать:**
- Системы с высокой нагрузкой на чтение
- Системы, где чтение и запись имеют разные требования
- Системы с сложными запросами

---

### 3. Saga Pattern

**Определение:**
Паттерн для управления распределенными транзакциями через события.

**Проблема:**
В микросервисах нет распределенных транзакций (2PC), но нужна атомарность операций.

**Решение:**
Разбиваем транзакцию на шаги, каждый шаг публикует событие, следующий шаг подписывается на событие.

**Типы Saga:**

**Choreography (Оркестрация через события):**
```
Order Service → OrderCreated event
  ↓
Payment Service подписывается → PaymentProcessed event
  ↓
Inventory Service подписывается → InventoryReserved event
  ↓
Order Service подписывается → OrderConfirmed
```

**Orchestration (Оркестрация через координатор):**
```
Order Orchestrator:
  1. Создает заказ
  2. Обрабатывает платеж
  3. Резервирует товары
  4. Подтверждает заказ
  
  При ошибке: выполняет компенсирующие транзакции
```

**Преимущества:**
- ✅ Управление распределенными транзакциями
- ✅ Компенсирующие транзакции при ошибках
- ✅ Атомарность на уровне бизнес-логики

**Недостатки:**
- ❌ Сложность реализации
- ❌ Eventual consistency
- ❌ Нужна обработка ошибок

**Когда использовать:**
- Распределенные транзакции в микросервисах
- Длинные бизнес-процессы
- Системы, где нужна атомарность без 2PC

---

## Технологии Event Bus

### Apache Kafka

**Характеристики:**
- Высокая пропускная способность
- Распределенная и отказоустойчивая
- Хранение событий (log retention)
- Поддержка множества consumers

**Когда использовать:**
- Высокая нагрузка (миллионы событий/сек)
- Нужно хранить события
- Множество consumers
- Большие объемы данных

**Пример:**
```python
from kafka import KafkaProducer, KafkaConsumer

# Producer
producer = KafkaProducer(bootstrap_servers='localhost:9092')
producer.send('orders', value=event_data)

# Consumer
consumer = KafkaConsumer('orders', bootstrap_servers='localhost:9092')
for message in consumer:
    process_event(message.value)
```

---

### RabbitMQ

**Характеристики:**
- Гибкие паттерны маршрутизации
- Поддержка различных exchange types
- Гарантия доставки
- Управление очередями

**Когда использовать:**
- Нужна гибкая маршрутизация
- Различные паттерны (pub/sub, routing, topics)
- Управляемые очереди
- Средняя нагрузка

---

### AWS Kinesis

**Характеристики:**
- Управляемый сервис (serverless)
- Автоматическое масштабирование
- Интеграция с AWS сервисами
- Real-time обработка

**Когда использовать:**
- AWS экосистема
- Real-time аналитика
- Stream processing
- Управляемый сервис

---

## Когда использовать Event-driven архитектуру

### ✅ Используйте когда:

1. **Независимые домены**
   - Сервисы слабо связаны
   - Разные команды разрабатывают сервисы

2. **Высокая нагрузка на запись**
   - Много событий генерируется
   - Асинхронная обработка критична

3. **Необходимость аудита**
   - Нужна история всех изменений
   - Требования к compliance

4. **Гибкость в развитии**
   - Нужно легко добавлять новые функции
   - Непредсказуемые требования

5. **Real-time обработка**
   - Нужна обработка событий в реальном времени
   - Stream processing

---

### ❌ НЕ используйте когда:

1. **Простая система**
   - Overhead не оправдан
   - Прямые вызовы проще

2. **Строгая консистентность**
   - Нужна immediate consistency
   - Eventual consistency недопустима

3. **Синхронные операции**
   - Нужен немедленный ответ
   - Асинхронность не подходит

4. **Ограниченные ресурсы**
   - Нет ресурсов на инфраструктуру
   - Простота важнее гибкости

---

## Примеры из реальных систем

### Netflix

**Архитектура:**
- Event-driven микросервисы
- Kafka для event streaming
- Event sourcing для некоторых сервисов
- CQRS для чтения/записи

**События:**
- VideoPlayed, VideoPaused, UserAction
- RecommendationUpdated
- ServiceHealthChanged

---

### Uber

**Архитектура:**
- Event-driven для координации сервисов
- Kafka для обработки событий
- Saga pattern для заказов поездок

**События:**
- TripRequested, DriverAssigned, TripCompleted
- PaymentProcessed
- LocationUpdated

---

### Amazon

**Архитектура:**
- Event-driven для e-commerce
- Kinesis для stream processing
- Event sourcing для заказов

**События:**
- OrderCreated, OrderShipped, OrderDelivered
- PaymentProcessed
- InventoryUpdated

---

## Резюме

**Ключевые принципы:**

1. ✅ **Decoupling** — компоненты не знают друг о друге
2. ✅ **Асинхронность** — неблокирующая обработка
3. ✅ **Масштабируемость** — независимое масштабирование
4. ✅ **Гибкость** — легко добавлять новые подписчики
5. ✅ **Аудит** — история всех изменений

**Паттерны:**
- **Event Sourcing** — хранение событий вместо состояния
- **CQRS** — разделение чтения и записи
- **Saga** — управление распределенными транзакциями

**Технологии:**
- **Kafka** — для высокой нагрузки
- **RabbitMQ** — для гибкой маршрутизации
- **Kinesis** — для AWS экосистемы

**Помните:** Event-driven архитектура — это мощный паттерн для сложных распределенных систем, но она добавляет сложность. Используйте её когда преимущества перевешивают недостатки.

