# ACID vs BASE

## Определение

**ACID** и **BASE** — это два противоположных подхода к проектированию систем управления данными, представляющие разные компромиссы между консистентностью и производительностью.

- **ACID** — фокус на **консистентность** и **надежность**
- **BASE** — фокус на **производительность** и **доступность**

---

## ACID

### Определение

**ACID** — это набор свойств транзакций в системах управления базами данных, гарантирующих надежность обработки данных.

**Расшифровка:**
- **A** — Atomicity (Атомарность)
- **C** — Consistency (Консистентность)
- **I** — Isolation (Изоляция)
- **D** — Durability (Долговечность)

---

### A — Atomicity (Атомарность)

**Определение:**
Транзакция выполняется **полностью или не выполняется вообще** — нет промежуточных состояний.

**Принцип "все или ничего":**
- Либо все операции транзакции выполняются успешно
- Либо ни одна операция не выполняется (rollback)

**Пример:**
```
Транзакция: Перевод $100 со счета A на счет B

Операция 1: Снять $100 со счета A ✅
Операция 2: Добавить $100 на счет B ❌ (ошибка)

Результат: Rollback операции 1
→ Счет A остается с исходным балансом
→ Транзакция не выполнена
```

**Реализация:**
- Commit — подтверждение всех изменений
- Rollback — откат всех изменений при ошибке
- Transaction log — журнал для восстановления

**Когда важно:**
- Финансовые операции
- Критичные бизнес-процессы
- Операции, где частичное выполнение недопустимо

---

### C — Consistency (Консистентность)

**Определение:**
Транзакция переводит базу данных из **одного валидного состояния в другое валидное состояние**.

**Принцип:**
- Данные всегда соответствуют правилам (constraints, foreign keys)
- Нет нарушений целостности данных
- Все инварианты сохраняются

**Пример:**
```
Правило: Баланс счета не может быть отрицательным

Транзакция: Снять $150 со счета с балансом $100

Результат: Транзакция отклонена (нарушение правила)
→ Баланс остается $100
→ Данные остаются консистентными
```

**Типы консистентности:**
- **Referential integrity** — внешние ключи
- **Check constraints** — проверочные ограничения
- **Unique constraints** — уникальные ограничения
- **Business rules** — бизнес-правила

**Когда важно:**
- Критичные данные
- Сложные бизнес-правила
- Системы, где недопустимы невалидные данные

---

### I — Isolation (Изоляция)

**Определение:**
Транзакции выполняются **изолированно** друг от друга — одна транзакция не видит незафиксированные изменения другой.

**Принцип:**
- Параллельные транзакции не мешают друг другу
- Каждая транзакция видит консистентное состояние данных
- Нет race conditions

**Уровни изоляции (от слабого к сильному):**

1. **Read Uncommitted** — видит незафиксированные изменения
2. **Read Committed** — видит только зафиксированные изменения
3. **Repeatable Read** — повторные чтения возвращают те же данные
4. **Serializable** — полная изоляция, как последовательное выполнение

**Проблемы при слабой изоляции:**

**Dirty Read:**
```
Транзакция 1: Обновляет баланс A = $200 (не зафиксировано)
Транзакция 2: Читает баланс A = $200 (видит незафиксированное)
Транзакция 1: Rollback
Транзакция 2: Видела неверные данные
```

**Non-repeatable Read:**
```
Транзакция 1: Читает баланс A = $100
Транзакция 2: Обновляет баланс A = $200 и commit
Транзакция 1: Читает баланс A = $200 (изменилось)
```

**Phantom Read:**
```
Транзакция 1: SELECT COUNT(*) WHERE status = 'active' → 10
Транзакция 2: INSERT новый active record и commit
Транзакция 1: SELECT COUNT(*) WHERE status = 'active' → 11 (новый record)
```

**Когда важно:**
- Параллельные транзакции
- Критичные операции
- Системы с высокой конкурентностью

---

### D — Durability (Долговечность)

**Определение:**
После успешного завершения транзакции (commit) **изменения сохраняются навсегда**, даже при сбоях системы.

**Принцип:**
- Изменения записываются на диск
- При сбое системы данные не теряются
- Можно восстановить состояние после сбоя

**Реализация:**
- **Write-ahead log (WAL)** — запись изменений в лог перед применением
- **Transaction log** — журнал всех транзакций
- **Checkpoints** — периодическое сохранение состояния
- **Replication** — копии данных на разных узлах

**Пример:**
```
Транзакция: Перевод $100 (commit выполнен)
→ Изменения записаны в transaction log
→ Система падает

После восстановления:
→ Данные восстанавливаются из transaction log
→ Перевод $100 сохранен
```

**Когда важно:**
- Критичные данные
- Финансовые операции
- Системы, где потеря данных недопустима

---

## ACID — Примеры систем

### Традиционные SQL БД

**PostgreSQL:**
- Полная поддержка ACID
- Транзакции с различными уровнями изоляции
- Write-ahead logging
- Используется для критичных данных

**MySQL (InnoDB):**
- Поддержка ACID
- Транзакции
- Используется для веб-приложений

**Oracle Database:**
- Полная поддержка ACID
- Продвинутые возможности транзакций
- Используется для enterprise систем

---

### Когда использовать ACID

**✅ Используйте ACID когда:**
- Критична точность данных (финансы, балансы)
- Нужна атомарность операций
- Недопустимы race conditions
- Сложные бизнес-правила
- Требования к compliance и аудиту

**Примеры:**
- Банковские системы
- Платежные системы
- Системы управления заказами
- Финансовые транзакции
- Системы резервирования

---

## BASE

### Определение

**BASE** — это подход к проектированию систем, который жертвует строгой консистентностью ради высокой производительности и доступности.

**Расшифровка:**
- **BA** — Basically Available (В основном доступна)
- **S** — Soft state (Мягкое состояние)
- **E** — Eventual consistency (Консистентность в конечном итоге)

**Философия:**
Вместо строгой консистентности в каждый момент времени, система гарантирует консистентность "в конечном итоге".

---

### BA — Basically Available (В основном доступна)

**Определение:**
Система **доступна большую часть времени**, даже при частичных сбоях.

**Принцип:**
- Система отвечает на запросы даже при проблемах
- Некоторые функции могут быть недоступны
- Graceful degradation (деградация функциональности)

**Пример:**
```
Система имеет 3 узла:
  Узел 1: доступен ✅
  Узел 2: доступен ✅
  Узел 3: недоступен ❌

Результат: Система продолжает работать
→ Запросы обрабатываются узлами 1 и 2
→ Система доступна, но с меньшей производительностью
```

**Характеристики:**
- Высокая доступность (99.9%+)
- Работа при частичных сбоях
- Нет полного отказа системы

**Когда важно:**
- Высоконагруженные системы
- Публичные API
- Системы, где доступность важнее точности

---

### S — Soft State (Мягкое состояние)

**Определение:**
Состояние системы **может меняться без новых входных данных** из-за eventual consistency.

**Принцип:**
- Состояние не фиксировано жестко
- Состояние может обновляться асинхронно
- Нет гарантии, что состояние актуально в каждый момент

**Пример:**
```
Пользователь A ставит лайк посту
→ Лайк записывается в узел 1
→ Счетчик лайков на узле 2 еще не обновлен
→ Состояние "мягкое" — может измениться без новых действий
```

**Характеристики:**
- Состояние может быть неконсистентным временно
- Состояние обновляется асинхронно
- Нет жесткой фиксации состояния

**Когда важно:**
- Высоконагруженные системы
- Системы с высокой конкурентностью
- Системы, где допустимы временные расхождения

---

### E — Eventual Consistency (Консистентность в конечном итоге)

**Определение:**
Система **в конечном итоге** придет к консистентному состоянию, если не будет новых изменений.

**Принцип:**
- Все узлы в конечном итоге увидят одинаковые данные
- Может пройти время (секунды, минуты) до синхронизации
- Гарантируется сходимость к консистентному состоянию

**Пример:**
```
Узел 1: X = 100
Узел 2: X = 100

Пользователь обновляет X = 200 на узле 1
→ Узел 1: X = 200 ✅
→ Узел 2: X = 100 (еще не обновлен)

Через несколько секунд:
→ Узел 1: X = 200 ✅
→ Узел 2: X = 200 ✅ (синхронизировано)
```

**Типы eventual consistency:**
- **Causal consistency** — причинно-следственная консистентность
- **Read-your-writes** — чтение своих записей всегда актуально
- **Session consistency** — консистентность в рамках сессии
- **Monotonic read** — монотонное чтение (не возвращается к старым значениям)

**Когда важно:**
- Высоконагруженные системы
- Географически распределенные системы
- Системы, где допустимы временные расхождения

---

## BASE — Примеры систем

### NoSQL БД

**Cassandra:**
- AP система (Availability + Partition tolerance)
- Eventual consistency
- Высокая доступность
- Используется для больших объемов данных

**DynamoDB:**
- AP система по умолчанию
- Eventual consistency
- Высокая производительность
- Используется для высоконагруженных систем

**CouchDB:**
- AP система
- Eventual consistency
- Multi-master replication
- Используется для распределенных систем

---

### Когда использовать BASE

**✅ Используйте BASE когда:**
- Критична производительность и доступность
- Допустимы временные расхождения данных
- Высокая нагрузка на чтение
- Географическое распределение
- Большие объемы данных

**Примеры:**
- Социальные сети (лайки, комментарии)
- E-commerce каталоги
- Системы аналитики
- Счетчики просмотров
- Рекомендательные системы

---

## Сравнение ACID vs BASE

| Характеристика | ACID | BASE |
|----------------|------|------|
| **Консистентность** | Strong (строгая) | Eventual (в конечном итоге) |
| **Доступность** | Может быть ограничена | Высокая |
| **Производительность** | Ниже (из-за блокировок) | Выше (без блокировок) |
| **Масштабируемость** | Ограничена | Высокая |
| **Сложность** | Проще (транзакции) | Сложнее (нужна обработка расхождений) |
| **Подходит для** | Критичные данные | Высоконагруженные системы |
| **Примеры БД** | PostgreSQL, MySQL | Cassandra, DynamoDB |

---

## Trade-offs (Компромиссы)

### ACID Trade-offs

**Преимущества:**
- ✅ Гарантированная консистентность
- ✅ Надежность данных
- ✅ Простота разработки (транзакции)

**Недостатки:**
- ❌ Ниже производительность (блокировки)
- ❌ Ограниченная масштабируемость
- ❌ Может быть недоступна при сбоях

---

### BASE Trade-offs

**Преимущества:**
- ✅ Высокая производительность
- ✅ Высокая доступность
- ✅ Хорошая масштабируемость

**Недостатки:**
- ❌ Возможны временные расхождения
- ❌ Сложность обработки неконсистентности
- ❌ Нужна дополнительная логика

---

## Гибридный подход

**Определение:**
Использование ACID для критичных операций и BASE для некритичных.

**Пример:**
```
E-commerce система:

ACID (критичные операции):
  - Создание заказа
  - Обработка платежей
  - Резервирование товаров

BASE (некритичные операции):
  - Каталог товаров
  - Рекомендации
  - Счетчики просмотров
```

**Преимущества:**
- ✅ Точность для критичных данных
- ✅ Производительность для некритичных данных
- ✅ Оптимальный баланс

---

## Примеры из реальных систем

### Банковская система (ACID)

**Требования:**
- Строгая консистентность балансов
- Атомарность переводов
- Надежность данных

**Решение:**
- PostgreSQL с ACID транзакциями
- Strong consistency
- Транзакции для всех операций

---

### Социальная сеть (BASE)

**Требования:**
- Высокая доступность
- Высокая производительность
- Допустимы временные расхождения

**Решение:**
- Cassandra для данных
- Eventual consistency для лайков/комментариев
- Strong consistency только для критичных операций

---

### E-commerce (Гибрид)

**Требования:**
- ACID для заказов и платежей
- BASE для каталога и рекомендаций

**Решение:**
- PostgreSQL для заказов (ACID)
- Cassandra для каталога (BASE)
- Разные уровни консистентности для разных данных

---

## Резюме

**Ключевые принципы:**

1. ✅ **ACID** — для критичных данных, где точность важнее производительности
2. ✅ **BASE** — для высоконагруженных систем, где производительность важнее точности
3. ✅ **Гибридный подход** — используйте оба подхода в одной системе для разных компонентов

**Правило выбора:**

- **ACID:**
  - Финансовые операции
  - Критичные бизнес-процессы
  - Системы, где недопустимы расхождения

- **BASE:**
  - Высоконагруженные системы
  - Системы, где допустимы временные расхождения
  - Географически распределенные системы

**Помните:** Выбор между ACID и BASE — это компромисс между консистентностью и производительностью. Правильный выбор зависит от конкретных требований системы.

