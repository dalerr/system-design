# Функциональные и нефункциональные требования

## Определение

При проектировании системы необходимо четко разделять **функциональные требования** (что система должна делать) и **нефункциональные требования** (как хорошо система должна это делать).

---

## Функциональные требования

### Определение

**Функциональные требования** описывают **что** система должна делать — основные функции и возможности, которые должна предоставлять система.

### Характеристики

- Описывают поведение системы
- Определяют входные и выходные данные
- Специфицируют бизнес-логику
- Формулируются с точки зрения пользователя/бизнеса

### Примеры функциональных требований

**E-commerce платформа:**
- Пользователь может искать товары по названию, категории, цене
- Пользователь может добавлять товары в корзину
- Пользователь может оформлять заказы
- Система обрабатывает платежи
- Система отправляет уведомления о статусе заказа
- Администратор может управлять каталогом товаров

**Платежная система (Stripe):**
- Система принимает данные платежных карт
- Система токенизирует номера карт (PCI DSS compliance)
- Система обрабатывает платежи через банковские сети
- Система проверяет транзакции на мошенничество
- Система отправляет webhooks мерчантам о статусе платежа
- Система ведет финансовый ledger всех транзакций

**Социальная сеть:**
- Пользователь может создавать посты
- Пользователь может ставить лайки и комментарии
- Пользователь может подписываться на других пользователей
- Система показывает ленту новостей
- Система отправляет уведомления о новых событиях

### Как формулировать функциональные требования

**Хорошие формулировки:**
- ✅ "Пользователь может искать товары по ключевым словам"
- ✅ "Система должна обрабатывать платежи через Stripe API"
- ✅ "Администратор может блокировать пользователей"

**Плохие формулировки:**
- ❌ "Система должна быть быстрой" (это нефункциональное требование)
- ❌ "Система должна использовать PostgreSQL" (это техническое решение, а не требование)
- ❌ "Система должна быть надежной" (это нефункциональное требование)

---

## Нефункциональные требования (SLAs)

### Определение

**Нефункциональные требования** (также называемые **SLAs** — Service Level Agreements) описывают **как хорошо** система должна выполнять свои функции — качественные характеристики системы.

### Ключевые метрики

#### 1. Throughput (пропускная способность)

**Определение:**
Количество операций, которые система может обработать за единицу времени.

**Единицы измерения:**
- Запросов в секунду (RPS — Requests Per Second)
- Транзакций в секунду (TPS — Transactions Per Second)
- Операций в минуту/час

**Примеры:**
- API Gateway: 100,000 RPS
- Платежная система: 10,000 TPS
- Поисковая система: 50,000 запросов/сек
- База данных: 5,000 запросов на запись/сек

**Как измерять:**
- Load testing (нагрузочное тестирование)
- Production мониторинг
- Stress testing (стресс-тестирование)

**Факторы, влияющие на throughput:**
- Производительность серверов
- Архитектура системы (синхронная vs асинхронная)
- Оптимизация БД (индексы, connection pooling)
- Кеширование

---

#### 2. Latency (задержка)

**Определение:**
Время от момента отправки запроса до получения ответа.

**Единицы измерения:**
- Миллисекунды (ms)
- Секунды (s)

**Процентили:**
- **p50 (медиана)** — 50% запросов выполняются быстрее этого значения
- **p95** — 95% запросов выполняются быстрее этого значения
- **p99** — 99% запросов выполняются быстрее этого значения
- **p99.9** — 99.9% запросов выполняются быстрее этого значения

**Примеры SLA по latency:**

**Критичные системы:**
- Платежная система: p99 < 2 секунды
- Торговая платформа: p95 < 100ms для операций покупки

**Высоконагруженные системы:**
- Поиск: p95 < 100ms
- Каталог товаров: p95 < 50ms
- API Gateway: p99 < 500ms

**Некритичные системы:**
- Аналитика: p95 < 5 секунд
- Отчеты: p95 < 30 секунд

**Факторы, влияющие на latency:**
- Сетевая задержка (network latency)
- Время обработки на сервере
- Время доступа к БД
- Время обработки в очередях
- Географическое расстояние

**Как измерять:**
```python
# Пример измерения latency
start_time = time.time()
response = process_request()
latency = time.time() - start_time
```

---

#### 3. Availability (доступность)

**Определение:**
Процент времени, в течение которого система доступна и работает корректно.

**Формула:**
```
Availability = (Total Time - Downtime) / Total Time × 100%
```

**Уровни доступности (девятки):**

| Девятки | Процент | Простой в год | Простой в месяц | Простой в неделю |
|---------|---------|---------------|-----------------|------------------|
| 99% | 99% | 3.65 дня | 7.2 часа | 1.68 часа |
| 99.9% | 99.9% | 8.76 часа | 43.2 минуты | 10.08 минуты |
| 99.99% | 99.99% | 52.56 минуты | 4.32 минуты | 1.01 минуты |
| 99.999% | 99.999% | 5.26 минуты | 25.9 секунды | 6.05 секунды |

**Примеры по типам систем:**

**Критичные системы (99.99%+):**
- Платежные системы: 99.99% (4 девятки)
- Медицинские системы: 99.99%
- Системы управления воздушным движением: 99.999%

**Важные системы (99.9%):**
- E-commerce платформы: 99.9% (3 девятки)
- Банковские приложения: 99.9%
- API сервисы: 99.9%

**Обычные системы (99%):**
- Внутренние инструменты: 99%
- Аналитические системы: 99%
- Тестовые среды: 99%

**Как достичь высокой доступности:**
- Репликация и failover
- Multi-region deployment
- Health checks и автоматическое восстановление
- Graceful degradation
- Circuit breakers

---

#### 4. Consistency (консистентность)

**Определение:**
Гарантия того, что все узлы распределенной системы видят одинаковые данные.

**Типы:**
- **Strong consistency** — все узлы видят одинаковые данные одновременно
- **Eventual consistency** — все узлы в конечном итоге придут к одинаковому состоянию
- **Weak consistency** — нет гарантий синхронизации

**Подробнее:** см. документ [consistency.md](./consistency.md)

**Примеры:**
- Банковские балансы: strong consistency
- Лайки в соцсетях: eventual consistency
- Кеши: weak consistency

---

#### 5. Data Volume (объем данных)

**Определение:**
Размер данных, которые система должна хранить и обрабатывать.

**Метрики:**
- Размер базы данных (GB, TB, PB)
- Скорость роста данных (GB/день, TB/месяц)
- Количество записей
- Размер отдельных объектов

**Примеры:**

**Большие системы:**
- YouTube: сотни петабайт видео
- Facebook: петабайты пользовательских данных
- Amazon: терабайты каталога товаров

**Средние системы:**
- E-commerce: терабайты каталога и заказов
- Социальная сеть: терабайты постов и медиа
- Аналитика: терабайты логов и метрик

**Малые системы:**
- Блог: гигабайты статей и изображений
- CRM: гигабайты клиентских данных

**Вопросы для уточнения:**
- Какой текущий объем данных?
- Как быстро растут данные?
- Нужно ли хранить исторические данные?
- Какие требования к retention (хранению)?

**Решения для больших объемов:**
- Шардинг (partitioning)
- Архивация старых данных
- Сжатие данных
- Холодное хранилище (cold storage)

---

#### 6. Scalability (масштабируемость)

**Определение:**
Способность системы обрабатывать увеличение нагрузки путем добавления ресурсов.

**Типы:**
- **Вертикальное масштабирование (Scale Up)** — увеличение ресурсов одного сервера
- **Горизонтальное масштабирование (Scale Out)** — добавление новых серверов

**Подробнее:** см. документ [scaling.md](./scaling.md)

**Вопросы для уточнения:**
- Ожидаемый рост нагрузки (2x, 10x, 100x)?
- Пиковая нагрузка vs средняя нагрузка?
- Сезонность (Black Friday, праздники)?

---

## Процесс сбора требований

### Шаги

1. **Уточнение функциональных требований**
   - Что должна делать система?
   - Кто пользователи системы?
   - Какие основные use cases?

2. **Уточнение масштаба**
   - Количество пользователей (DAU, MAU)
   - Количество запросов в секунду (RPS)
   - Объем данных
   - Географическое распределение

3. **Определение приоритетов**
   - Какие требования критичны?
   - Какие требования можно ослабить?
   - Какие trade-offs допустимы?

4. **Документирование**
   - Зафиксировать все требования
   - Определить метрики успеха
   - Установить SLA

### Типичные вопросы на интервью

**О масштабе:**
- Сколько пользователей ожидается?
- Сколько запросов в секунду?
- Какой объем данных?
- Какая география пользователей?

**О производительности:**
- Какая допустимая задержка?
- Какой нужен throughput?
- Какая доступность критична?

**О данных:**
- Какие данные нужно хранить?
- Как быстро растут данные?
- Нужна ли история изменений?

**О функциональности:**
- Какие основные функции?
- Какие edge cases нужно обработать?
- Какие интеграции нужны?

---

## Trade-offs между требованиями

### Консистентность vs Производительность

- **Strong consistency** → выше надежность, но ниже throughput
- **Eventual consistency** → выше производительность, но возможны расхождения

**Пример:**
- Банковский баланс: выбираем strong consistency (точность важнее скорости)
- Счетчик лайков: выбираем eventual consistency (скорость важнее точности)

### Доступность vs Консистентность

- **Высокая доступность** → система работает даже при сбоях, но возможны расхождения
- **Strong consistency** → данные всегда точны, но система может быть недоступна при сбоях

**Пример:**
- Платежная система: выбираем CP (consistency + partition tolerance)
- Социальная сеть: выбираем AP (availability + partition tolerance)

### Latency vs Throughput

- **Низкая latency** → быстрые ответы, но меньше одновременных запросов
- **Высокий throughput** → больше запросов, но возможны задержки

**Пример:**
- Поиск: низкая latency важнее (p95 < 100ms)
- Batch обработка: высокий throughput важнее (миллионы записей/час)

---

## Примеры требований для реальных систем

### Stripe (платежная система)

**Функциональные:**
- Обработка платежей через карты, банковские переводы
- Токенизация карт (PCI DSS)
- Проверка на мошенничество
- Webhooks для уведомлений

**Нефункциональные:**
- Throughput: 1M транзакций/день
- Latency: p99 < 2 секунды
- Availability: 99.99% (4 девятки)
- Consistency: strong для финансовых данных
- Data volume: терабайты транзакций

### Amazon E-commerce

**Функциональные:**
- Поиск товаров
- Каталог товаров
- Корзина и заказы
- Платежи и логистика

**Нефункциональные:**
- Throughput: 100K RPS на поиск, 50K RPS на каталог
- Latency: поиск < 100ms (p95), каталог < 50ms (p95)
- Availability: 99.9% для критичных сервисов
- Consistency: eventual для каталога, strong для заказов
- Data volume: 1B+ товаров в каталоге

### YouTube

**Функциональные:**
- Загрузка и воспроизведение видео
- Поиск видео
- Комментарии и лайки
- Рекомендации

**Нефункциональные:**
- Throughput: миллионы просмотров/день
- Latency: начало воспроизведения < 2 секунды
- Availability: 99.9%
- Consistency: eventual для лайков/комментариев
- Data volume: сотни петабайт видео

---

## Резюме

**Ключевые принципы:**

1. ✅ **Начинайте с требований** — не проектируйте без понимания что нужно
2. ✅ **Уточняйте масштаб** — задавайте вопросы о пользователях, нагрузке, данных
3. ✅ **Учитывайте trade-offs** — понимайте компромиссы между требованиями
4. ✅ **Документируйте** — фиксируйте все требования и SLA
5. ✅ **Приоритизируйте** — определяйте что критично, а что можно ослабить

**Помните:** Правильно собранные требования — основа хорошего системного дизайна. Неправильные или неполные требования приводят к неправильным архитектурным решениям.

