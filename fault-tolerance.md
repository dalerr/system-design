# Стратегии отказоустойчивости

## Определение

**Отказоустойчивость (Fault Tolerance)** — это способность системы продолжать работать корректно даже при частичных сбоях компонентов.

В распределенных системах сбои неизбежны: серверы падают, сеть разрывается, базы данных перегружаются. Отказоустойчивая система должна уметь обрабатывать эти сбои и продолжать предоставлять сервис.

---

## Принципы отказоустойчивости

### 1. Предполагайте сбои (Assume Failures)

**Принцип:**
Сбои не являются исключением — они нормальны в распределенных системах. Система должна быть спроектирована с учетом того, что компоненты будут падать.

**Статистика:**
- Серверы падают в среднем раз в год
- Сетевые разрывы происходят регулярно
- Диски выходят из строя
- Провайдеры облачных сервисов имеют downtime

**Вывод:**
Не "если произойдет сбой", а "когда произойдет сбой".

---

### 2. Изоляция сбоев (Failure Isolation)

**Принцип:**
Сбой одного компонента не должен приводить к каскадному отказу всей системы.

**Как достичь:**
- Разделение на независимые сервисы
- Circuit breakers для изоляции проблемных сервисов
- Timeout и retry механизмы
- Graceful degradation

---

### 3. Быстрое восстановление (Fast Recovery)

**Принцип:**
Система должна быстро обнаруживать сбои и восстанавливаться.

**Как достичь:**
- Health checks для мониторинга состояния
- Автоматический failover
- Автоматический restart упавших сервисов
- Мониторинг и алертинг

---

## Основные стратегии отказоустойчивости

### 1. Replication (репликация)

**Определение:**
Создание копий данных или сервисов на нескольких узлах для обеспечения доступности при сбоях.

#### Типы репликации

**Master-Slave (Primary-Replica):**
- Один master для записи
- Несколько slaves для чтения
- При падении master → один из slaves становится новым master

**Пример:**
```
Master DB (запись)
    ├── Slave 1 (чтение, реплика)
    ├── Slave 2 (чтение, реплика)
    └── Slave 3 (чтение, реплика)
```

**Преимущества:**
- ✅ Высокая доступность
- ✅ Масштабирование чтения (read scaling)
- ✅ Резервное копирование

**Недостатки:**
- ❌ Задержка репликации (replication lag)
- ❌ Сложность failover

**Технологии:**
- PostgreSQL (streaming replication)
- MySQL (master-slave replication)
- MongoDB (replica sets)

---

**Master-Master (Multi-Master):**
- Несколько masters, каждый может принимать записи
- Синхронизация между masters

**Пример:**
```
Master 1 (запись) ←→ Master 2 (запись)
    ↓                    ↓
  Slave 1              Slave 2
```

**Преимущества:**
- ✅ Высокая доступность
- ✅ Географическое распределение
- ✅ Нет single point of failure

**Недостатки:**
- ❌ Сложность разрешения конфликтов
- ❌ Сложность синхронизации

**Технологии:**
- MySQL (multi-master replication)
- PostgreSQL (бидирекциональная репликация)
- Cassandra (multi-datacenter replication)

---

### 2. Failover (переключение)

**Определение:**
Автоматическое переключение на резервный компонент при сбое основного.

#### Типы failover

**Active-Passive (Hot Standby):**
- Активный компонент обрабатывает запросы
- Пассивный компонент готов заменить активный
- При сбое активного → пассивный становится активным

**Пример:**
```
Active Server (обрабатывает запросы)
    ↓
Passive Server (готов заменить, но не обрабатывает)
```

**Преимущества:**
- ✅ Быстрое переключение
- ✅ Простота реализации

**Недостатки:**
- ❌ Неэффективное использование ресурсов (passive простаивает)

---

**Active-Active:**
- Оба компонента активны и обрабатывают запросы
- При сбое одного → другой берет на себя всю нагрузку

**Пример:**
```
Active Server 1 (обрабатывает 50% запросов)
    ↓
Active Server 2 (обрабатывает 50% запросов)
```

**Преимущества:**
- ✅ Эффективное использование ресурсов
- ✅ Высокая доступность

**Недостатки:**
- ❌ Сложность реализации
- ❌ Нужна синхронизация состояния

---

**Автоматический vs Ручной:**
- **Автоматический failover** — система сама переключается (быстрее, но может быть рискованно)
- **Ручной failover** — администратор переключает вручную (безопаснее, но медленнее)

---

### 3. Circuit Breaker (предохранитель)

**Определение:**
Паттерн, который предотвращает каскадные отказы, временно блокируя запросы к проблемному сервису.

#### Состояния Circuit Breaker

**Closed (Закрыт) — нормальная работа:**
- Запросы проходят к сервису
- Мониторинг ошибок
- При превышении порога ошибок → переход в Open

**Open (Открыт) — сервис недоступен:**
- Запросы не проходят к сервису
- Сразу возвращается ошибка (без вызова сервиса)
- Через некоторое время → переход в Half-Open

**Half-Open (Полуоткрыт) — тестирование:**
- Пропускается ограниченное количество запросов
- Если успешно → переход в Closed
- Если ошибки → возврат в Open

**Пример реализации:**
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        self.last_failure_time = None
    
    def call(self, service_func):
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise CircuitBreakerOpenError()
        
        try:
            result = service_func()
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
            raise e
```

**Преимущества:**
- ✅ Предотвращает каскадные отказы
- ✅ Быстрая реакция на проблемы
- ✅ Экономит ресурсы (не отправляет запросы к недоступному сервису)

**Недостатки:**
- ❌ Может блокировать запросы к временно недоступному сервису
- ❌ Нужна правильная настройка порогов

**Технологии:**
- Netflix Hystrix (deprecated, но концепция актуальна)
- Resilience4j (Java)
- Polly (.NET)
- Custom implementation

---

### 4. Retry с Exponential Backoff

**Определение:**
Повторная попытка выполнения операции при временных сбоях с экспоненциально увеличивающейся задержкой между попытками.

**Почему exponential backoff:**
- Временные сбои часто быстро проходят
- Не перегружаем проблемный сервис постоянными запросами
- Даем время сервису восстановиться

**Пример:**
```
Попытка 1: сразу
Попытка 2: через 1 секунду
Попытка 3: через 2 секунды
Попытка 4: через 4 секунды
Попытка 5: через 8 секунд
...
```

**Реализация:**
```python
import time
import random

def retry_with_backoff(func, max_retries=5, base_delay=1):
    for attempt in range(max_retries):
        try:
            return func()
        except TemporaryError as e:
            if attempt == max_retries - 1:
                raise e
            
            # Exponential backoff с jitter
            delay = base_delay * (2 ** attempt)
            jitter = random.uniform(0, 0.1 * delay)
            time.sleep(delay + jitter)
    
    raise MaxRetriesExceeded()
```

**Когда использовать:**
- ✅ Временные сетевые сбои
- ✅ Временная перегрузка сервиса
- ✅ Транзиентные ошибки (timeout, connection refused)

**Когда НЕ использовать:**
- ❌ Постоянные ошибки (404, 401, validation errors)
- ❌ Критичные операции, которые нельзя повторять (платежи)

**Важно:**
- Используйте **idempotency keys** для операций, которые нельзя повторять
- Ограничьте количество попыток
- Используйте jitter (случайную задержку) для предотвращения thundering herd

---

### 5. Graceful Degradation (деградация)

**Определение:**
Способность системы продолжать работать с ограниченной функциональностью при сбоях некоторых компонентов.

**Принцип:**
Лучше показать частично работающую систему, чем полностью недоступную.

**Примеры:**

**E-commerce при сбое рекомендаций:**
- ✅ Показываем товары без рекомендаций
- ✅ Показываем популярные товары вместо персонализированных

**Социальная сеть при сбое уведомлений:**
- ✅ Основной функционал работает
- ✅ Уведомления отправляются позже, когда сервис восстановится

**Поиск при сбое индекса:**
- ✅ Показываем кешированные результаты
- ✅ Показываем популярные запросы

**Реализация:**
```python
def get_recommendations(user_id):
    try:
        return recommendation_service.get(user_id)
    except ServiceUnavailable:
        # Graceful degradation
        return get_popular_items()  # Fallback
```

**Преимущества:**
- ✅ Система остается доступной
- ✅ Пользователи могут продолжать работать
- ✅ Лучший UX, чем полный отказ

**Недостатки:**
- ❌ Нужно проектировать fallback логику
- ❌ Может быть сложно определить, что критично, а что нет

---

### 6. Health Checks и Мониторинг

**Определение:**
Регулярная проверка состояния компонентов системы для раннего обнаружения проблем.

#### Типы Health Checks

**Liveness Check (проверка живости):**
- Проверяет, что процесс работает
- Если не проходит → процесс перезапускается

**Readiness Check (проверка готовности):**
- Проверяет, что сервис готов обрабатывать запросы
- Если не проходит → сервис исключается из load balancer

**Пример:**
```python
@app.route('/health/live')
def liveness():
    # Простая проверка, что процесс работает
    return {"status": "alive"}, 200

@app.route('/health/ready')
def readiness():
    # Проверка зависимостей
    if not db.is_connected():
        return {"status": "not ready"}, 503
    
    if not cache.is_connected():
        return {"status": "not ready"}, 503
    
    return {"status": "ready"}, 200
```

**Мониторинг:**
- Метрики производительности (CPU, memory, latency)
- Метрики бизнес-логики (количество запросов, ошибок)
- Логирование ошибок
- Алертинг при проблемах

**Технологии:**
- Prometheus + Grafana
- Datadog
- New Relic
- CloudWatch (AWS)
- ELK Stack (Elasticsearch, Logstash, Kibana)

---

## Дополнительные стратегии

### 1. Timeout (таймауты)

**Определение:**
Ограничение времени ожидания ответа от сервиса.

**Зачем:**
- Предотвращает бесконечное ожидание
- Быстрое обнаружение проблем
- Освобождение ресурсов

**Пример:**
```python
import requests

response = requests.get(
    'https://api.example.com/data',
    timeout=5  # 5 секунд
)
```

**Рекомендации:**
- Устанавливайте timeout на всех внешних вызовах
- Используйте разные timeout для разных операций
- Учитывайте сетевую задержку

---

### 2. Bulkhead Pattern

**Определение:**
Изоляция ресурсов для предотвращения каскадных отказов.

**Пример:**
- Отдельный thread pool для критичных операций
- Отдельные connection pool для разных сервисов
- Ограничение ресурсов для некритичных операций

**Реализация:**
```python
# Отдельный thread pool для платежей
payment_executor = ThreadPoolExecutor(max_workers=10)

# Отдельный thread pool для уведомлений
notification_executor = ThreadPoolExecutor(max_workers=50)
```

---

### 3. Timeout и Circuit Breaker вместе

**Комбинация стратегий:**
```python
# Сначала timeout
try:
    result = call_with_timeout(service, timeout=5)
except TimeoutError:
    # Затем circuit breaker
    circuit_breaker.record_failure()
    raise
```

---

## Примеры из реальных систем

### Netflix

**Стратегии:**
- Circuit Breaker (Hystrix)
- Retry с exponential backoff
- Graceful degradation
- Multi-region deployment

**Результат:**
- Высокая доступность даже при сбоях отдельных сервисов
- Продолжает работать при проблемах в одном регионе

---

### Amazon

**Стратегии:**
- Multi-region replication
- Automatic failover
- Health checks
- Graceful degradation

**Результат:**
- Высокая доступность даже при сбоях в одном регионе
- Продолжает работать при проблемах с отдельными сервисами

---

### Google

**Стратегии:**
- Redundancy на всех уровнях
- Automatic recovery
- Health checks и мониторинг
- Graceful degradation

**Результат:**
- Очень высокая доступность (99.99%+)
- Быстрое восстановление после сбоев

---

## Резюме

**Ключевые принципы:**

1. ✅ **Предполагайте сбои** — они неизбежны
2. ✅ **Изолируйте сбои** — один сбой не должен ломать всю систему
3. ✅ **Быстро восстанавливайтесь** — автоматическое обнаружение и восстановление
4. ✅ **Используйте комбинацию стратегий** — не полагайтесь на одну стратегию
5. ✅ **Мониторьте и алертьте** — знайте о проблемах до того, как пользователи их заметят

**Чек-лист отказоустойчивости:**

- [ ] Репликация критичных данных
- [ ] Автоматический failover
- [ ] Circuit breakers для внешних сервисов
- [ ] Retry с exponential backoff
- [ ] Timeout на всех внешних вызовах
- [ ] Graceful degradation для некритичных функций
- [ ] Health checks и мониторинг
- [ ] Алертинг при проблемах
- [ ] Документация процедур восстановления

**Помните:** Отказоустойчивость — это не опциональная функция, а необходимость для production систем. Правильно спроектированная система должна продолжать работать даже при сбоях компонентов.

