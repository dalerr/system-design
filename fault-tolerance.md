# Стратегии отказоустойчивости

## Определение

**Отказоустойчивость (Fault Tolerance)** — это способность системы продолжать работать корректно даже при частичных сбоях компонентов.

В распределенных системах сбои неизбежны: серверы падают, сеть разрывается, базы данных перегружаются. Отказоустойчивая система должна уметь обрабатывать эти сбои и продолжать предоставлять сервис.

---

## Принципы отказоустойчивости

### 1. Предполагайте сбои (Assume Failures)

**Принцип:**
Сбои не являются исключением — они нормальны в распределенных системах. Система должна быть спроектирована с учетом того, что компоненты будут падать.

**Статистика:**
- Серверы падают в среднем раз в год
- Сетевые разрывы происходят регулярно
- Диски выходят из строя
- Провайдеры облачных сервисов имеют downtime

**Вывод:**
Не "если произойдет сбой", а "когда произойдет сбой".

---

### 2. Изоляция сбоев (Failure Isolation)

**Принцип:**
Сбой одного компонента не должен приводить к каскадному отказу всей системы.

**Как достичь:**
- Разделение на независимые сервисы
- Circuit breakers для изоляции проблемных сервисов
- Timeout и retry механизмы
- Graceful degradation

---

### 3. Быстрое восстановление (Fast Recovery)

**Принцип:**
Система должна быстро обнаруживать сбои и восстанавливаться.

**Как достичь:**
- Health checks для мониторинга состояния
- Автоматический failover
- Автоматический restart упавших сервисов
- Мониторинг и алертинг

---

## Основные стратегии отказоустойчивости

### 1. Replication (репликация)

**Определение:**
Создание копий данных или сервисов на нескольких узлах для обеспечения доступности при сбоях.

#### Типы репликации

**Master-Slave (Primary-Replica):**
- Один master для записи
- Несколько slaves для чтения
- При падении master → один из slaves становится новым master

**Пример:**
```
Master DB (запись)
    ├── Slave 1 (чтение, реплика)
    ├── Slave 2 (чтение, реплика)
    └── Slave 3 (чтение, реплика)
```

**Преимущества:**
- ✅ Высокая доступность
- ✅ Масштабирование чтения (read scaling)
- ✅ Резервное копирование

**Недостатки:**
- ❌ Задержка репликации (replication lag)
- ❌ Сложность failover

**Технологии:**
- PostgreSQL (streaming replication)
- MySQL (master-slave replication)
- MongoDB (replica sets)

---

**Master-Master (Multi-Master):**
- Несколько masters, каждый может принимать записи
- Синхронизация между masters

**Пример:**
```
Master 1 (запись) ←→ Master 2 (запись)
    ↓                    ↓
  Slave 1              Slave 2
```

**Преимущества:**
- ✅ Высокая доступность
- ✅ Географическое распределение
- ✅ Нет single point of failure

**Недостатки:**
- ❌ Сложность разрешения конфликтов
- ❌ Сложность синхронизации

**Технологии:**
- MySQL (multi-master replication)
- PostgreSQL (бидирекциональная репликация)
- Cassandra (multi-datacenter replication)

---

#### Как обеспечивается синхронизация в Master-Master системах

**Проблема:**
В master-master системах оба узла могут принимать записи одновременно. Это создает проблемы:
- Конфликты при записи одних и тех же данных
- Порядок операций может различаться
- Нужна синхронизация изменений между узлами

**Основные механизмы синхронизации:**

##### 1. Асинхронная репликация (Asynchronous Replication)

**Принцип:**
- Master 1 записывает данные локально
- Изменения асинхронно отправляются на Master 2
- Master 2 применяет изменения после получения

**Пример:**
```
Master 1: INSERT user (id=1, name="Alice")
  ↓ (асинхронно, через несколько миллисекунд)
Master 2: Получает и применяет INSERT user (id=1, name="Alice")
```

**Преимущества:**
- ✅ Низкая latency записи (не ждем подтверждения от другого master)
- ✅ Высокая производительность
- ✅ Работает даже при временной недоступности другого master

**Недостатки:**
- ❌ Возможны конфликты при одновременной записи
- ❌ Eventual consistency (временные расхождения)
- ❌ Возможна потеря данных при сбое до синхронизации

**Технологии:**
- MySQL (multi-master с асинхронной репликацией)
- PostgreSQL (бидирекциональная репликация с задержкой)

---

##### 2. Синхронная репликация (Synchronous Replication)

**Принцип:**
- Master 1 записывает данные локально
- Ждет подтверждения от Master 2, что данные записаны
- Только после подтверждения транзакция считается завершенной

**Пример:**
```
Master 1: INSERT user (id=1, name="Alice")
  ↓ (синхронно, ждем подтверждения)
Master 2: Получает, записывает, отправляет подтверждение
  ↓
Master 1: Получает подтверждение → транзакция commit
```

**Преимущества:**
- ✅ Гарантированная консистентность (нет расхождений)
- ✅ Нет потери данных при сбое
- ✅ Strong consistency

**Недостатки:**
- ❌ Высокая latency (ждем сетевого round-trip)
- ❌ Может быть недоступен при сбое другого master
- ❌ Ниже производительность

**Технологии:**
- PostgreSQL (синхронная репликация)
- MySQL (semi-synchronous replication)

---

##### 3. Conflict Resolution (Разрешение конфликтов)

**Проблема:**
При одновременной записи одних и тех же данных на разных masters возникают конфликты.

**Стратегии разрешения конфликтов:**

**Last Write Wins (LWW):**
- Побеждает запись с более поздним timestamp
- Простая, но может терять данные

**Пример:**
```
Master 1 (10:00:00): UPDATE user SET name="Alice"
Master 2 (10:00:01): UPDATE user SET name="Bob"

Результат: name="Bob" (более поздний timestamp)
```

**Vector Clocks:**
- Отслеживание причинно-следственных связей
- Более точное определение порядка операций

**Пример:**
```
Master 1: [1, 0] - выполнил 1 операцию
Master 2: [0, 1] - выполнил 1 операцию
При конфликте: определяем порядок по векторным часам
```

**Application-level Resolution:**
- Приложение само решает конфликты
- Бизнес-логика определяет победителя

**Пример:**
```
Конфликт: Два пользователя редактируют один документ
Решение: Merge изменений или показать оба варианта пользователю
```

**Automatic Merge:**
- Автоматическое слияние изменений
- Для структур данных, поддерживающих merge (CRDTs)

**Пример:**
```
Master 1: Добавляет элемент в список [A, B]
Master 2: Добавляет элемент в список [A, C]

Результат: [A, B, C] (автоматический merge)
```

---

##### 4. Шардинг по ключам (Key-based Sharding)

**Принцип:**
Разные masters отвечают за разные ключи/диапазоны данных.

**Пример:**
```
Master 1: Пользователи с ID 1-1000
Master 2: Пользователи с ID 1001-2000

Нет конфликтов, так как разные masters обрабатывают разные данные
```

**Преимущества:**
- ✅ Нет конфликтов (разные данные)
- ✅ Высокая производительность
- ✅ Простота реализации

**Недостатки:**
- ❌ Нужна маршрутизация запросов
- ❌ Сложнее балансировка нагрузки

---

##### 5. Event Sourcing и CQRS

**Принцип:**
- Храним события вместо текущего состояния
- Masters синхронизируют события
- Состояние вычисляется из событий

**Пример:**
```
Master 1: Публикует событие UserCreated {id: 1, name: "Alice"}
Master 2: Получает событие → применяет → состояние синхронизировано
```

**Преимущества:**
- ✅ Полная история изменений
- ✅ Легче разрешать конфликты (по событиям)
- ✅ Аудит всех операций

**Недостатки:**
- ❌ Сложность реализации
- ❌ Нужно пересчитывать состояние

---

##### 6. Distributed Consensus (Распределенный консенсус)

**Принцип:**
Использование алгоритмов консенсуса (Raft, Paxos) для согласования изменений.

**Как работает:**
- Все masters участвуют в голосовании
- Изменение применяется только при достижении консенсуса
- Гарантирует порядок операций

**Пример:**
```
Master 1: Предлагает изменение X
→ Все masters голосуют
→ При большинстве голосов → изменение применяется
→ Порядок операций гарантирован
```

**Преимущества:**
- ✅ Гарантированный порядок операций
- ✅ Strong consistency
- ✅ Нет конфликтов

**Недостатки:**
- ❌ Высокая latency (нужен консенсус)
- ❌ Сложность реализации
- ❌ Может быть недоступен при сбое большинства

**Технологии:**
- etcd (Raft)
- Consul (Raft)
- MongoDB (Raft для replica sets)

---

#### Примеры реализации в реальных системах

##### MySQL Multi-Master

**Механизм:**
- Асинхронная репликация через binlog
- Auto-increment offset для избежания конфликтов ID
- Conflict resolution через application logic

**Пример конфигурации:**
```sql
-- Master 1
server-id = 1
auto-increment-offset = 1
auto-increment-increment = 2

-- Master 2
server-id = 2
auto-increment-offset = 2
auto-increment-increment = 2

Результат: Master 1 генерирует ID: 1, 3, 5, 7...
          Master 2 генерирует ID: 2, 4, 6, 8...
          Нет конфликтов ID
```

**Синхронизация:**
```
Master 1: INSERT → записывает в binlog
  ↓ (асинхронно)
Master 2: Читает binlog Master 1 → применяет изменения
```

---

##### PostgreSQL Bi-directional Replication

**Механизм:**
- Логическая репликация (logical replication)
- Асинхронная синхронизация
- Conflict resolution через правила

**Пример:**
```sql
-- На Master 1
CREATE PUBLICATION master1_pub FOR TABLE users;

-- На Master 2
CREATE SUBSCRIPTION master2_sub 
  CONNECTION 'host=master1' 
  PUBLICATION master1_pub;
```

**Синхронизация:**
```
Master 1: Изменения → WAL → публикация
  ↓
Master 2: Подписка → получение → применение
```

---

##### Cassandra Multi-Datacenter

**Механизм:**
- Асинхронная репликация между дата-центрами
- Conflict resolution через timestamps (LWW)
- Tunable consistency levels

**Пример:**
```
Datacenter 1 (US): Запись с timestamp T1
Datacenter 2 (EU): Запись с timestamp T2

При чтении: Побеждает запись с более поздним timestamp
```

**Consistency Levels:**
- **ONE** — быстрая запись, eventual consistency
- **QUORUM** — баланс между скоростью и консистентностью
- **ALL** — медленная запись, strong consistency

---

#### Рекомендации по выбору механизма синхронизации

**Асинхронная репликация:**
- ✅ Высокая производительность важнее консистентности
- ✅ Географическое распределение (высокая network latency)
- ✅ Допустимы временные расхождения

**Синхронная репликация:**
- ✅ Критична консистентность данных
- ✅ Низкая network latency между masters
- ✅ Недопустима потеря данных

**Conflict Resolution:**
- ✅ Высокая конкурентность записи
- ✅ Нужна стратегия разрешения конфликтов
- ✅ Application-level логика для merge

**Шардинг:**
- ✅ Четкое разделение данных
- ✅ Нет пересечений в данных между masters
- ✅ Простота реализации

**Distributed Consensus:**
- ✅ Критичен порядок операций
- ✅ Strong consistency обязательна
- ✅ Готовность к высокой latency

---

#### Типичные проблемы и решения

**Проблема 1: Split-brain (разделение мозга)**
```
Ситуация: Masters потеряли связь друг с другом
Проблема: Оба masters считают себя активными
Решение: Quorum, majority voting, или ручное вмешательство
```

**Проблема 2: Replication Lag (задержка репликации)**
```
Ситуация: Master 2 отстает от Master 1
Проблема: Чтение с Master 2 показывает устаревшие данные
Решение: Read from master для критичных операций, или ждем синхронизации
```

**Проблема 3: Write Conflicts (конфликты записи)**
```
Ситуация: Оба masters обновляют одну запись одновременно
Проблема: Какой вариант победит?
Решение: Conflict resolution стратегия (LWW, merge, application logic)
```

---

### 2. Failover (переключение)

**Определение:**
Автоматическое переключение на резервный компонент при сбое основного.

#### Типы failover

**Active-Passive (Hot Standby):**
- Активный компонент обрабатывает запросы
- Пассивный компонент готов заменить активный
- При сбое активного → пассивный становится активным

**Пример:**
```
Active Server (обрабатывает запросы)
    ↓
Passive Server (готов заменить, но не обрабатывает)
```

**Преимущества:**
- ✅ Быстрое переключение
- ✅ Простота реализации

**Недостатки:**
- ❌ Неэффективное использование ресурсов (passive простаивает)

---

**Active-Active:**
- Оба компонента активны и обрабатывают запросы
- При сбое одного → другой берет на себя всю нагрузку

**Пример:**
```
Active Server 1 (обрабатывает 50% запросов)
    ↓
Active Server 2 (обрабатывает 50% запросов)
```

**Преимущества:**
- ✅ Эффективное использование ресурсов
- ✅ Высокая доступность

**Недостатки:**
- ❌ Сложность реализации
- ❌ Нужна синхронизация состояния

---

**Автоматический vs Ручной:**
- **Автоматический failover** — система сама переключается (быстрее, но может быть рискованно)
- **Ручной failover** — администратор переключает вручную (безопаснее, но медленнее)

---

### 3. Circuit Breaker (предохранитель)

**Определение:**
Паттерн, который предотвращает каскадные отказы, временно блокируя запросы к проблемному сервису.

#### Состояния Circuit Breaker

**Closed (Закрыт) — нормальная работа:**
- Запросы проходят к сервису
- Мониторинг ошибок
- При превышении порога ошибок → переход в Open

**Open (Открыт) — сервис недоступен:**
- Запросы не проходят к сервису
- Сразу возвращается ошибка (без вызова сервиса)
- Через некоторое время → переход в Half-Open

**Half-Open (Полуоткрыт) — тестирование:**
- Пропускается ограниченное количество запросов
- Если успешно → переход в Closed
- Если ошибки → возврат в Open

**Пример реализации:**
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        self.last_failure_time = None
    
    def call(self, service_func):
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise CircuitBreakerOpenError()
        
        try:
            result = service_func()
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
            raise e
```

**Преимущества:**
- ✅ Предотвращает каскадные отказы
- ✅ Быстрая реакция на проблемы
- ✅ Экономит ресурсы (не отправляет запросы к недоступному сервису)

**Недостатки:**
- ❌ Может блокировать запросы к временно недоступному сервису
- ❌ Нужна правильная настройка порогов

**Технологии:**
- Netflix Hystrix (deprecated, но концепция актуальна)
- Resilience4j (Java)
- Polly (.NET)
- Custom implementation

---

### 4. Retry с Exponential Backoff

**Определение:**
Повторная попытка выполнения операции при временных сбоях с экспоненциально увеличивающейся задержкой между попытками.

**Почему exponential backoff:**
- Временные сбои часто быстро проходят
- Не перегружаем проблемный сервис постоянными запросами
- Даем время сервису восстановиться

**Пример:**
```
Попытка 1: сразу
Попытка 2: через 1 секунду
Попытка 3: через 2 секунды
Попытка 4: через 4 секунды
Попытка 5: через 8 секунд
...
```

**Реализация:**
```python
import time
import random

def retry_with_backoff(func, max_retries=5, base_delay=1):
    for attempt in range(max_retries):
        try:
            return func()
        except TemporaryError as e:
            if attempt == max_retries - 1:
                raise e
            
            # Exponential backoff с jitter
            delay = base_delay * (2 ** attempt)
            jitter = random.uniform(0, 0.1 * delay)
            time.sleep(delay + jitter)
    
    raise MaxRetriesExceeded()
```

**Когда использовать:**
- ✅ Временные сетевые сбои
- ✅ Временная перегрузка сервиса
- ✅ Транзиентные ошибки (timeout, connection refused)

**Когда НЕ использовать:**
- ❌ Постоянные ошибки (404, 401, validation errors)
- ❌ Критичные операции, которые нельзя повторять (платежи)

**Важно:**
- Используйте **idempotency keys** для операций, которые нельзя повторять
- Ограничьте количество попыток
- Используйте jitter (случайную задержку) для предотвращения thundering herd

---

### 5. Graceful Degradation (деградация)

**Определение:**
Способность системы продолжать работать с ограниченной функциональностью при сбоях некоторых компонентов.

**Принцип:**
Лучше показать частично работающую систему, чем полностью недоступную.

**Примеры:**

**E-commerce при сбое рекомендаций:**
- ✅ Показываем товары без рекомендаций
- ✅ Показываем популярные товары вместо персонализированных

**Социальная сеть при сбое уведомлений:**
- ✅ Основной функционал работает
- ✅ Уведомления отправляются позже, когда сервис восстановится

**Поиск при сбое индекса:**
- ✅ Показываем кешированные результаты
- ✅ Показываем популярные запросы

**Реализация:**
```python
def get_recommendations(user_id):
    try:
        return recommendation_service.get(user_id)
    except ServiceUnavailable:
        # Graceful degradation
        return get_popular_items()  # Fallback
```

**Преимущества:**
- ✅ Система остается доступной
- ✅ Пользователи могут продолжать работать
- ✅ Лучший UX, чем полный отказ

**Недостатки:**
- ❌ Нужно проектировать fallback логику
- ❌ Может быть сложно определить, что критично, а что нет

---

### 6. Health Checks и Мониторинг

**Определение:**
Регулярная проверка состояния компонентов системы для раннего обнаружения проблем.

#### Типы Health Checks

**Liveness Check (проверка живости):**
- Проверяет, что процесс работает
- Если не проходит → процесс перезапускается

**Readiness Check (проверка готовности):**
- Проверяет, что сервис готов обрабатывать запросы
- Если не проходит → сервис исключается из load balancer

**Пример:**
```python
@app.route('/health/live')
def liveness():
    # Простая проверка, что процесс работает
    return {"status": "alive"}, 200

@app.route('/health/ready')
def readiness():
    # Проверка зависимостей
    if not db.is_connected():
        return {"status": "not ready"}, 503
    
    if not cache.is_connected():
        return {"status": "not ready"}, 503
    
    return {"status": "ready"}, 200
```

**Мониторинг:**
- Метрики производительности (CPU, memory, latency)
- Метрики бизнес-логики (количество запросов, ошибок)
- Логирование ошибок
- Алертинг при проблемах

**Технологии:**
- Prometheus + Grafana
- Datadog
- New Relic
- CloudWatch (AWS)
- ELK Stack (Elasticsearch, Logstash, Kibana)

---

## Дополнительные стратегии

### 1. Timeout (таймауты)

**Определение:**
Ограничение времени ожидания ответа от сервиса.

**Зачем:**
- Предотвращает бесконечное ожидание
- Быстрое обнаружение проблем
- Освобождение ресурсов

**Пример:**
```python
import requests

response = requests.get(
    'https://api.example.com/data',
    timeout=5  # 5 секунд
)
```

**Рекомендации:**
- Устанавливайте timeout на всех внешних вызовах
- Используйте разные timeout для разных операций
- Учитывайте сетевую задержку

---

### 2. Bulkhead Pattern

**Определение:**
Изоляция ресурсов для предотвращения каскадных отказов.

**Пример:**
- Отдельный thread pool для критичных операций
- Отдельные connection pool для разных сервисов
- Ограничение ресурсов для некритичных операций

**Реализация:**
```python
# Отдельный thread pool для платежей
payment_executor = ThreadPoolExecutor(max_workers=10)

# Отдельный thread pool для уведомлений
notification_executor = ThreadPoolExecutor(max_workers=50)
```

---

### 3. Timeout и Circuit Breaker вместе

**Комбинация стратегий:**
```python
# Сначала timeout
try:
    result = call_with_timeout(service, timeout=5)
except TimeoutError:
    # Затем circuit breaker
    circuit_breaker.record_failure()
    raise
```

---

## Примеры из реальных систем

### Netflix

**Стратегии:**
- Circuit Breaker (Hystrix)
- Retry с exponential backoff
- Graceful degradation
- Multi-region deployment

**Результат:**
- Высокая доступность даже при сбоях отдельных сервисов
- Продолжает работать при проблемах в одном регионе

---

### Amazon

**Стратегии:**
- Multi-region replication
- Automatic failover
- Health checks
- Graceful degradation

**Результат:**
- Высокая доступность даже при сбоях в одном регионе
- Продолжает работать при проблемах с отдельными сервисами

---

### Google

**Стратегии:**
- Redundancy на всех уровнях
- Automatic recovery
- Health checks и мониторинг
- Graceful degradation

**Результат:**
- Очень высокая доступность (99.99%+)
- Быстрое восстановление после сбоев

---

## Резюме

**Ключевые принципы:**

1. ✅ **Предполагайте сбои** — они неизбежны
2. ✅ **Изолируйте сбои** — один сбой не должен ломать всю систему
3. ✅ **Быстро восстанавливайтесь** — автоматическое обнаружение и восстановление
4. ✅ **Используйте комбинацию стратегий** — не полагайтесь на одну стратегию
5. ✅ **Мониторьте и алертьте** — знайте о проблемах до того, как пользователи их заметят

**Чек-лист отказоустойчивости:**

- [ ] Репликация критичных данных
- [ ] Автоматический failover
- [ ] Circuit breakers для внешних сервисов
- [ ] Retry с exponential backoff
- [ ] Timeout на всех внешних вызовах
- [ ] Graceful degradation для некритичных функций
- [ ] Health checks и мониторинг
- [ ] Алертинг при проблемах
- [ ] Документация процедур восстановления

**Помните:** Отказоустойчивость — это не опциональная функция, а необходимость для production систем. Правильно спроектированная система должна продолжать работать даже при сбоях компонентов.

