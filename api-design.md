# Проектирование API

## Определение

**API (Application Programming Interface)** — это контракт между сервисами, определяющий как они взаимодействуют друг с другом.

---

## Типы API

### REST (Representational State Transfer)

**Определение:**
Стандарт архитектуры для веб-сервисов, использующий HTTP методы для работы с ресурсами.

**Характеристики:**
- Использует HTTP методы (GET, POST, PUT, DELETE, PATCH)
- Stateless — каждый запрос независим
- Ресурсы идентифицируются через URL
- Использует стандартные HTTP статус коды

**Принципы REST:**

1. **Ресурсы (Resources)** — сущности системы (users, orders, products)
2. **HTTP методы** — операции над ресурсами
3. **Статус коды** — результат операции (200, 201, 404, 500)
4. **Идемпотентность** — многократное выполнение операции дает тот же эффект, что и однократное

**Пример REST API:**
```
GET    /api/users          # Получить список пользователей
GET    /api/users/123      # Получить пользователя с ID 123
POST   /api/users          # Создать нового пользователя
PUT    /api/users/123       # Обновить пользователя (полная замена)
PATCH  /api/users/123      # Частичное обновление пользователя
DELETE /api/users/123      # Удалить пользователя
```

---

### Версионирование API

**Проблема:**
При изменении API нужно поддерживать обратную совместимость или версионировать изменения.

**Стратегии версионирования:**

**1. URL версионирование:**
```
/api/v1/users
/api/v2/users
```
- ✅ Простота реализации
- ✅ Явная версия в URL
- ❌ Загромождает URL

**2. Header версионирование:**
```
Accept: application/vnd.api+json;version=2
```
- ✅ Чистые URL
- ❌ Сложнее для клиентов

**3. Query параметр:**
```
/api/users?version=2
```
- ✅ Простота
- ❌ Нестандартный подход

**Рекомендация:**
Используйте URL версионирование для простоты и явности.

---

### Идемпотентность

**Определение:**
Идемпотентность означает, что многократное выполнение операции приводит к тому же состоянию системы, что и однократное выполнение. Это не означает, что результат запроса будет идентичным (данные могут измениться между запросами), но эффект операции одинаковый.

**Важно понимать:**
- Идемпотентность относится к эффекту операции, а не к результату запроса
- GET запрос может вернуть разные данные, но сам запрос идемпотентен (не меняет состояние)
- PUT запрос устанавливает ресурс в определенное состояние — многократное выполнение дает тот же эффект

**Примеры идемпотентных операций:**

**GET (чтение):**
```
GET /api/users/123
```
- Идемпотентен: не меняет состояние системы
- Результат может отличаться (если данные пользователя изменились), но эффект одинаковый (чтение)

**PUT (полная замена):**
```
PUT /api/users/123 {"name": "John", "email": "john@example.com"}
PUT /api/users/123 {"name": "John", "email": "john@example.com"}  # Повтор
```
- Идемпотентен: многократное выполнение устанавливает пользователя в то же состояние
- Эффект одинаковый: пользователь с ID 123 имеет name="John" и email="john@example.com"

**DELETE:**
```
DELETE /api/users/123
DELETE /api/users/123  # Повтор
```
- Идемпотентен: после первого удаления пользователя нет, последующие удаления не меняют состояние
- Эффект одинаковый: пользователь удален

**Примеры НЕ идемпотентных операций:**

**POST (создание):**
```
POST /api/users {"name": "John"}
POST /api/users {"name": "John"}  # Повтор
```
- НЕ идемпотентен: каждое выполнение создает нового пользователя
- Эффект разный: создается второй пользователь

**PATCH (частичное обновление):**
```
PATCH /api/users/123 {"balance": 100}  # Увеличить баланс на 100
PATCH /api/users/123 {"balance": 100}  # Повтор
```
- Может быть не идемпотентным: зависит от реализации
- Если это "увеличить на 100", то не идемпотентен (баланс увеличится дважды)
- Если это "установить в 100", то идемпотентен

**Идемпотентность для критичных операций:**
- Используйте idempotency keys для POST операций, которые должны быть идемпотентными
- Клиент отправляет уникальный ключ с запросом
- Сервер проверяет ключ и возвращает тот же результат при повторном запросе

**Пример с idempotency key:**
```
POST /api/payments
Headers: Idempotency-Key: abc123
Body: {"amount": 100, "currency": "USD"}

# При повторном запросе с тем же ключом:
POST /api/payments
Headers: Idempotency-Key: abc123
Body: {"amount": 100, "currency": "USD"}

# Сервер возвращает тот же результат (не создает второй платеж)
```

**HTTP методы и идемпотентность:**
- **GET, PUT, DELETE** — должны быть идемпотентными по спецификации HTTP
- **POST** — обычно не идемпотентен, но можно сделать идемпотентным через idempotency keys
- **PATCH** — может быть идемпотентным или нет, зависит от реализации

---

### GraphQL

**Определение:**
Язык запросов для API, позволяющий клиенту запрашивать только нужные поля данных.

**Характеристики:**
- Один endpoint вместо множества REST endpoints
- Клиент определяет структуру ответа
- Строгая типизация через схему

**Пример запроса:**
```graphql
query {
  user(id: "123") {
    name
    email
    orders {
      id
      total
    }
  }
}
```

**Преимущества GraphQL:**
- ✅ Гибкость — клиент запрашивает только нужные данные
- ✅ Меньше over-fetching (получение лишних данных)
- ✅ Один endpoint вместо множества
- ✅ Строгая типизация
- ✅ Автоматическая документация через схему

**Недостатки GraphQL:**
- ❌ Сложнее кеширование (нет стандартных HTTP кешей)
- ❌ Сложнее rate limiting
- ❌ Может привести к N+1 проблемам
- ❌ Сложнее для простых случаев
- ❌ Нужна дополнительная инфраструктура (GraphQL сервер)

**Когда использовать GraphQL:**
- Мобильные приложения с ограниченным трафиком
- Сложные запросы с множеством связанных данных
- Когда клиенты имеют разные требования к данным
- Когда важна гибкость запросов

**Когда НЕ использовать GraphQL:**
- Простые CRUD операции
- Когда нужны стандартные HTTP кеши
- Когда важна простота реализации

---

### gRPC

**Определение:**
Высокопроизводительный RPC фреймворк от Google, использующий Protocol Buffers для сериализации.

**Характеристики:**
- Бинарный протокол (выше производительность)
- Строгая типизация через protobuf
- Поддерживает streaming (односторонний и двусторонний)
- HTTP/2 под капотом

**Пример protobuf определения:**
```protobuf
service UserService {
  rpc GetUser(UserRequest) returns (UserResponse);
  rpc ListUsers(Empty) returns (stream User);
}

message UserRequest {
  string id = 1;
}

message UserResponse {
  string id = 1;
  string name = 2;
  string email = 3;
}
```

**Преимущества gRPC:**
- ✅ Высокая производительность (бинарный протокол)
- ✅ Строгая типизация через protobuf
- ✅ Поддержка streaming
- ✅ Автоматическая генерация кода
- ✅ Меньше размер сообщений по сравнению с JSON

**Недостатки gRPC:**
- ❌ Не поддерживается браузерами напрямую (нужен gRPC-Web)
- ❌ Сложнее дебаг (бинарный формат)
- ❌ Меньше инструментов по сравнению с REST
- ❌ Сложнее для простых случаев

**Когда использовать gRPC:**
- Внутренние сервисы (микросервисы)
- Высоконагруженные системы
- Когда нужен streaming
- Когда важна производительность
- Когда нужна строгая типизация

**Когда НЕ использовать gRPC:**
- Публичные API для веб-приложений
- Когда нужна простота реализации
- Когда важна совместимость с браузерами

---

## API Gateway

**Определение:**
Единая точка входа для всех клиентов, обрабатывающая общие задачи перед маршрутизацией запросов к микросервисам.

**Функции API Gateway:**

1. **Аутентификация и авторизация:**
   - Проверка токенов (JWT, OAuth)
   - Проверка API keys
   - Управление доступом

2. **Rate limiting:**
   - Ограничение количества запросов
   - Защита от злоупотреблений
   - Разные лимиты для разных клиентов

3. **Маршрутизация:**
   - Направление запросов к нужным сервисам
   - Load balancing между инстансами сервисов
   - Версионирование маршрутов

4. **Кеширование:**
   - Кеширование ответов
   - Снижение нагрузки на backend
   - Улучшение latency

5. **Логирование и мониторинг:**
   - Сбор метрик и логов
   - Трейсинг запросов
   - Аналитика использования API

6. **Трансформация:**
   - Преобразование форматов данных
   - Агрегация ответов от нескольких сервисов
   - Адаптация для разных клиентов

7. **Load balancing:**
   - Распределение нагрузки между сервисами
   - Health checks для определения доступных сервисов

**Примеры API Gateway:**
- AWS API Gateway
- Kong
- NGINX
- Envoy
- Zuul (Netflix)
- Traefik

**Архитектура с API Gateway:**
```
Client → API Gateway → Service 1
                    → Service 2
                    → Service 3
```

**Преимущества:**
- ✅ Единая точка входа
- ✅ Централизованная обработка общих задач
- ✅ Упрощение клиентского кода
- ✅ Безопасность на уровне gateway

**Недостатки:**
- ❌ Single point of failure (нужна репликация)
- ❌ Дополнительная задержка
- ❌ Сложность настройки

---

## Документация API

**Важность:**
Хорошая документация критична для использования API разработчиками.

**Форматы документации:**

**1. OpenAPI (Swagger):**
- Стандарт для REST API
- YAML или JSON формат
- Автоматическая генерация документации и клиентов

**Пример OpenAPI:**
```yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
paths:
  /users/{id}:
    get:
      summary: Get user
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: User found
```

**2. GraphQL Schema:**
- Автоматическая документация для GraphQL
- Интроспекция схемы
- Интерактивные инструменты (GraphiQL, Apollo Studio)

**3. gRPC:**
- Документация через protobuf комментарии
- Автоматическая генерация из .proto файлов

**Best practices документации:**
- ✅ Включайте примеры запросов и ответов
- ✅ Описывайте все возможные ошибки
- ✅ Обновляйте документацию при изменениях
- ✅ Используйте интерактивные инструменты
- ✅ Включайте rate limits и ограничения

---

## Best Practices проектирования API

### Общие принципы

1. **Используйте стандартные HTTP методы и статус коды**
   - GET для чтения
   - POST для создания
   - PUT для полной замены
   - PATCH для частичного обновления
   - DELETE для удаления

2. **Версионируйте API с самого начала**
   - Планируйте изменения заранее
   - Поддерживайте обратную совместимость
   - Документируйте breaking changes

3. **Обеспечьте идемпотентность для критичных операций**
   - Используйте idempotency keys для POST
   - GET, PUT, DELETE должны быть идемпотентными

4. **Используйте пагинацию для больших списков**
   - Не возвращайте все данные сразу
   - Используйте курсоры или offset/limit
   - Включайте метаданные о пагинации

5. **Обрабатывайте ошибки единообразно**
   - Стандартный формат ошибок
   - Понятные сообщения об ошибках
   - Правильные HTTP статус коды

6. **Документируйте API**
   - OpenAPI/Swagger для REST
   - Интерактивные инструменты
   - Примеры использования

7. **Используйте rate limiting**
   - Защита от злоупотреблений
   - Разные лимиты для разных клиентов
   - Возвращайте информацию о лимитах в headers

8. **Логируйте все запросы**
   - Для дебага и мониторинга
   - Включайте correlation IDs
   - Не логируйте чувствительные данные

9. **Используйте HTTPS**
   - Безопасность передачи данных
   - Обязательно для production

10. **Оптимизируйте производительность**
    - Кеширование где возможно
    - Минимизация размера ответов
    - Использование compression

---

## Сравнительная таблица типов API

| Характеристика | REST | GraphQL | gRPC |
|----------------|------|---------|------|
| **Протокол** | HTTP/1.1, HTTP/2 | HTTP/1.1, HTTP/2 | HTTP/2 |
| **Формат данных** | JSON, XML | JSON | Protocol Buffers |
| **Типизация** | Слабая | Строгая (схема) | Строгая (protobuf) |
| **Кеширование** | Стандартное HTTP | Сложное | Сложное |
| **Производительность** | Средняя | Средняя | Высокая |
| **Поддержка браузеров** | Полная | Полная | Через gRPC-Web |
| **Сложность** | Низкая | Средняя | Высокая |
| **Лучше для** | Публичные API | Гибкие запросы | Внутренние сервисы |

---

## Резюме

**Ключевые принципы:**

1. ✅ **Выбирайте правильный тип API** — REST для простых случаев, GraphQL для гибкости, gRPC для производительности
2. ✅ **Версионируйте с начала** — планируйте изменения заранее
3. ✅ **Обеспечьте идемпотентность** — критично для надежности
4. ✅ **Документируйте хорошо** — упрощает использование
5. ✅ **Используйте API Gateway** — централизует общие задачи
6. ✅ **Следуйте best practices** — стандарты, безопасность, производительность

**Помните:** Хорошо спроектированное API — это основа успешной системы. Плохое API усложняет интеграцию и использование системы.

